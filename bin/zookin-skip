#!/usr/bin/env node

var ProgressBar = require('progress');
var fs = require("fs");
var Event = require("events").EventEmitter;
var skip = require(__dirname + "/../lib/cipher/Skip");
var validate = require(__dirname + "/../lib/validateString");

var prgm = require("commander");
prgm.option("-c, --cipher-text <text>", "Text to encrypt or decrypt")
    .option("-e, --encrypt", "Set mode to encrypt")
    .option("-d, --decrypt", "Set mode to decrypt")
    .option("-k, --key <skip num>", "Number of letters to skip for encryption/decryption", parseInt)
    .option("-b, --bruteforce", "Attempt to bruteforce the cipher")
    .option("--depth <int>", "Specify the depth of word requirement", parseInt)
    .parse(process.argv);

if (!prgm.hasOwnProperty("cipherText")) {
    console.error("Error: Required switch: -c");
    prgm.help();
}
if (prgm.bruteforce) {
    if (prgm.key || prgm.decrypt || prgm.encrypt) {
        console.error("Error: Incompatible switches");
        prgm.help();
    }
    console.log("Attempting to bruteforce Skip Ciphertext: " + prgm.cipherText);
    var go = new Event();
    var top = [];
    for (var i = 0; i < 25; i++)
        top.push(["", 0, 0]);
    function insert(string, score, key) {
        for (var i = 0; i < top.length; i++) {
            if (score > top[i][1]) {
                top[i] = [string, score, key];
                break;
            }
        }
    }
    function shutdown() {
        process.stdout.write("\x1b[?25h");
        process.stdout.write("\x1b[0m\n");
        process.exit();
    }

    process.stdout.write("\x1b[?25l");
    var bar = new ProgressBar('\x1b[35mSkip\x1b[0m    [\x1b[34m:current\x1b[0m / \x1b[34m:total\x1b[0m][\x1b[34m:percent\x1b[0m][\x1b[34m:elapsed\x1b[0ms - \x1b[34m:eta\x1b[0ms] \x1b[33m╢\x1b[0m:bar\x1b[33m╟\x1b[0m :word', {
        total: prgm.cipherText.length,
        stream: process.stdout,
        width: process.stdout.columns,
        complete: "\x1b[32m█\x1b[0m",
        incomplete: "\x1b[31m░\x1b[0m",
        renderThrottle: 5000,
        callback: function() {
            console.log("");
            console.log("(p%)\trank. passphrase used: resultant text\x1b[32m");
            for (var i = 0; i < top.length; i++)
                if (top[i][1])
                    console.log("(" + Math.floor(100 * top[i][1] / top[0][1]) + ")\t" + (i+1) + ". " + top[i][2] +  ": " + top[i][0] + "\x1b[0m");
            shutdown();
        }
    });

    var counterIndex = 0;
    go.on("next", function() {
        bar.tick({word: counterIndex});
        var res = skip(-1, prgm.cipherText, counterIndex, 0);
        if (res) {
            var sc = validate(res, prgm.depth ? prgm.depth : 1);
            if (sc > top[top.length-1][1]) {
                insert(res,sc,counterIndex);
            }
        }
        counterIndex++;
        if (counterIndex < prgm.cipherText.length)
            process.nextTick(function() {
                go.emit("next");
            });
    });
    go.emit("next");

    process.on("exit", shutdown);
    process.on("SIGINT", shutdown);
    process.on("SIGHUP", shutdown);
} else if (prgm.encrypt) {
    console.log(skip(1, prgm.cipherText, prgm.key ? prgm.key : 1, 0));
} else if (prgm.decrypt) {
    console.log(skip(-1, prgm.cipherText, prgm.key ? prgm.key : 1, 0));
}
